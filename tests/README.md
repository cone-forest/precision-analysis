# Tests for Precision Analysis Library

This directory contains comprehensive tests for the precision-analysis library.

## Running Tests

### Run all tests
```bash
pytest tests/
```

### Run with verbose output
```bash
pytest tests/ -v
```

### Run specific test file
```bash
pytest tests/test_utils.py
```

### Run with coverage
```bash
pytest tests/ --cov=src --cov-report=html
```

## Test Structure

- `test_utils.py` - Tests for utility functions (transformations, CSV loading, error calculations)
- `test_algorithms.py` - Tests for all calibration algorithms (tsai-lenz, park-martin, daniilidis, li-wang-wu, shah)
- `test_noise.py` - Tests for noise generation functions (Perlin and Gaussian noise)
- `test_functions_call.py` - Tests for the main API functions
- `test_end_to_end.py` - End-to-end tests with pre-generated test data files
- `conftest.py` - Shared pytest fixtures and configuration

## Understanding Test Data: A and B Datasets

### What are A and B?

The test data consists of pairs of files (e.g., `known_transform_A.txt` and `known_transform_B.txt`):

- **Dataset A**: Contains poses measured in coordinate frame A (e.g., robot base frame)
- **Dataset B**: Contains the **same poses** measured in coordinate frame B (e.g., camera/sensor frame)

### Key Concept

**A and B represent the same physical trajectory, just expressed in different coordinate systems.**

Each row in file A corresponds to the same row in file B - they represent the same physical pose at the same moment in time, but measured from different reference frames.

### Mathematical Relationship

The poses in frames A and B are related by:

```
B = Y⁻¹ @ A @ X
```

In the test data, Y is typically identity (for simplicity), so:
```
B = A @ X
```

Where:
- **A** = pose in coordinate frame A
- **B** = same pose in coordinate frame B
- **X** = transformation from frame A to frame B (what the calibration algorithms find)
- **Y** = additional transformation (usually identity in test data)

### Real-World Example

Imagine a robot arm moving through space:
- **Frame A**: Measurements from the robot's base sensor
- **Frame B**: Measurements from a camera watching the robot
- Both sensors observe the **same motion**, but report coordinates in their own reference frames
- The calibration algorithms find the transformation **X** that converts between these two frames

### Example from Test Data

```
Pose 0:
  Frame A: [0.00, 0.00, 0.00] mm
  Frame B: [49.92, 100.02, 24.93] mm
  (Same physical location, different coordinate systems)
```

### The Calibration Problem

Given pairs of poses (A_i, B_i) for i = 1...n, the algorithms find:
- **X**: Transformation from frame A to frame B
- **Y**: Additional transformation (if needed)

Such that: `Y @ B_i = A_i @ X` for all i

### Test Data Generation

Test data is generated by `generate_test_data.py`:
1. Creates synthetic trajectories (known_transform, circular, helix, etc.)
2. Applies a known transformation X between frames
3. Generates corresponding poses in both frames
4. Adds noise to the B poses to simulate real-world measurement errors
5. Saves files in format: `id X Y Z RZ RY RX`

The generated test data files are committed to the repository for reproducibility.

## Test Coverage

The test suite covers:
- ✅ Transformation matrix operations (inversion, composition)
- ✅ Euler angle conversions
- ✅ CSV file loading and parsing
- ✅ Error calculation and statistics
- ✅ All five calibration algorithms
- ✅ Noise generation (Perlin and Gaussian)
- ✅ Main API functions

## End-to-End Tests

The `test_end_to_end.py` file contains comprehensive end-to-end tests that:
- Load pre-generated test data files from `tests/data/`
- Test all calibration algorithms on various trajectories
- Validate results against algorithm-specific and noise-level-specific thresholds
- Test with multiple noise levels (0.1mm, 1.0mm, 5.0mm) to ensure robustness

### Test Data Files

Test data files are located in `tests/data/` and include:
- **Small datasets**: `known_transform` (10 poses), `circular_trajectory` (8 poses)
- **Large datasets**: `helix_trajectory`, `complex_3d_path`, `figure8_trajectory` (1000 poses each)
- **Multiple noise levels**: Each dataset has variants with 0.1mm, 1.0mm, and 5.0mm position noise

### Regenerating Test Data

If you need to regenerate test data files:

```bash
# Generate all test cases with all noise levels
python tests/generate_test_data.py --all-levels

# Generate specific test case with specific noise levels
python tests/generate_test_data.py --test-case known_transform --noise-levels 0.1 1.0 5.0
```

## Notes

- Some algorithms (notably Shah) may fail to converge with certain inputs. These cases are handled gracefully with skipped tests.
- Noise generation tests are skipped if the corresponding modules are not available.
- Tests use temporary files that are automatically cleaned up.
- Test data files are committed to the repository (not generated on-the-fly) for reproducibility and CI/CD compatibility.


